//! A particle of smoke

use std::f32::consts::PI;

use glam::Vec2;
use rand::Rng;

/// "Size", or more appro"area of influence" of a particle
pub const PARTICLE_SIZE: f32 = 16.0;
/// Just a cache for a frequently used calculation
pub const PARTICLE_SIZE_SQUARED: f32 = PARTICLE_SIZE * PARTICLE_SIZE;
/// Mass of the particle
const MASS: f32 = 2.5;
/// ?
const GAS_CONST: f32 = 2000.0;
/// ?
const REST_DENSITY: f32 = 300.0;
/// Viscosity of the gas/liquid
const VISCOSITY: f32 = 200.0;

/// Timestep, therefore how detailed to make the simulation
const TIMESTEP: f32 = 0.0007;
/// How quickly to bring a particle's velocity back into bounds
const BOUND_DAMPING: f32 = -0.5;

// Manually write out powers since `f32::powf` is not yet a `const fn`
/// ?
static POLY6: f32 = 4.0
    / (PI
        * PARTICLE_SIZE
        * PARTICLE_SIZE
        * PARTICLE_SIZE
        * PARTICLE_SIZE
        * PARTICLE_SIZE
        * PARTICLE_SIZE
        * PARTICLE_SIZE
        * PARTICLE_SIZE);
/// ?
static SPIKY_GRAD: f32 =
    -10.0 / (PI * PARTICLE_SIZE * PARTICLE_SIZE * PARTICLE_SIZE * PARTICLE_SIZE * PARTICLE_SIZE);
/// ?
static VISC_LAP: f32 =
    40.0 / (PI * PARTICLE_SIZE * PARTICLE_SIZE * PARTICLE_SIZE * PARTICLE_SIZE * PARTICLE_SIZE);

/// Colour of a gas particle
type Colour = (f32, f32, f32);

/// A single particle of gas
#[derive(Clone, PartialEq, Debug)]
#[non_exhaustive]
pub struct Particle {
    /// Position of a particle
    pub created_at: std::time::Instant,
    /// Scale of the simulation
    pub scale: f32,
    /// Position of a particle
    pub position: Vec2,
    /// Velocity of a  particle
    pub velocity: Vec2,
    /// Force of a  particle
    pub force: Vec2,
    /// Density of the particle
    pub density: f32,
    /// Density of the particle
    pub pressure: f32,
    /// Colour of a gas particle
    pub colour: Colour,
    /// Whether this particle is locked in place. It still contributes its denisty, pressure, etc
    /// to the rest of the simulation, but it doesn't change its own position.
    pub is_immovable: bool,
}

#[allow(
    clippy::cast_precision_loss,
    clippy::as_conversions,
    clippy::arithmetic_side_effects,
    clippy::float_arithmetic,
    clippy::indexing_slicing
)]
impl Particle {
    /// Add the density generated by another particle
    pub fn accumulate_density(&mut self, other: &Self) {
        let delta = other.position - self.position;
        let distance_squared = delta.length_squared();
        self.density += MASS * POLY6 * f32::powf(PARTICLE_SIZE_SQUARED - distance_squared, 3.0);
    }

    /// Calculate forces on the particle
    #[must_use]
    pub fn calculate_forces(&self, other: &Self) -> Option<Vec2> {
        let delta = other.position - self.position;
        let distance = delta.length();

        let force_from_pressure = -delta.normalize() * MASS * (self.pressure + other.pressure)
            / (2.0 * other.density)
            * SPIKY_GRAD
            * f32::powf(PARTICLE_SIZE - distance, 3.0);

        let force_from_viscosity = VISCOSITY * MASS * (other.velocity - self.velocity)
            / other.density
            * VISC_LAP
            * (PARTICLE_SIZE - distance);

        let force = force_from_pressure + force_from_viscosity;
        Some(force)
    }

    /// Given the acummulated density of a particle and its neighbours, calculate its presssure
    pub fn update_pressure(&mut self) {
        self.pressure = GAS_CONST * (self.density - REST_DENSITY);
    }

    /// The force from gravity
    #[must_use]
    pub fn force_from_gravity(&self, gravity: Vec2) -> Vec2 {
        gravity * MASS / self.density
    }

    /// Apply the forces to the velocity and then actually move the particle
    pub fn integrate(&mut self) {
        if self.is_immovable {
            return;
        }
        let velocity = TIMESTEP * self.force / self.density;
        if velocity.is_nan() {
            tracing::error!("Velocity is NaN");
            return;
        }
        self.velocity += velocity;
        self.position += TIMESTEP * self.velocity;
    }

    /// Keep the particles in the container
    pub fn boundaries(&mut self, width: f32, height: f32) {
        if self.position.x < 0.0 {
            self.velocity.x *= BOUND_DAMPING;
            self.position.x = 0.0;
        }
        if self.position.x > width - 1.0 {
            self.velocity.x *= BOUND_DAMPING;
            self.position.x = width - 1.0;
        }
        if self.position.y < 0.0 {
            self.velocity.y *= BOUND_DAMPING;
            self.position.y = 0.0;
        }
        if self.position.y > height - 1.0 {
            self.velocity.y *= BOUND_DAMPING;
            self.position.y = height - 1.0;
        }
    }

    /// The position of the particle in the same scale as they were added
    #[must_use]
    pub fn position_unscaled(&self) -> Vec2 {
        self.position / self.scale
    }

    /// A particle that can move
    #[must_use]
    pub fn default_movable(scale: f32, velocity: Vec2, x: f32, y: f32) -> Self {
        let ish_range = 0.01;
        let colour_ish = rand::thread_rng().gen_range(-ish_range..ish_range);
        let colour = (0.15 + colour_ish, 0.15 + colour_ish, 0.15 + colour_ish);
        Self {
            created_at: std::time::Instant::now(),
            scale,
            position: Vec2::new(x * scale, y * scale),
            density: 1.0,
            colour,
            velocity,
            force: Vec2::ZERO,
            pressure: 0.0,
            is_immovable: false,
        }
    }

    /// A particle that can't move
    #[must_use]
    pub fn default_immovable(scale: f32, x: f32, y: f32) -> Self {
        Self {
            created_at: std::time::Instant::now(),
            scale,
            position: Vec2::new(x * scale, y * scale),
            density: 1.0,
            colour: (1.0, 1.0, 1.0),
            velocity: Vec2::ZERO,
            force: Vec2::ZERO,
            pressure: 0.0,
            is_immovable: true,
        }
    }
}

impl Default for Particle {
    fn default() -> Self {
        Self {
            created_at: std::time::Instant::now(),
            scale: 1.0,
            position: Vec2::ZERO,
            density: 1.0,
            colour: Colour::default(),
            velocity: Vec2::ZERO,
            force: Vec2::ZERO,
            pressure: 0.0,
            is_immovable: false,
        }
    }
}

impl rstar::RTreeObject for Particle {
    type Envelope = rstar::AABB<[f32; 2]>;

    fn envelope(&self) -> Self::Envelope {
        rstar::AABB::from_point([self.position.x, self.position.y])
    }
}

#[allow(clippy::missing_trait_methods)]
impl rstar::PointDistance for Particle {
    fn distance_2(&self, point: &[f32; 2]) -> f32 {
        let other = Vec2::new(point[0], point[1]);
        self.position.distance_squared(other)
    }
}
